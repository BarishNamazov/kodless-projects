{
  "concepts": {
    "user.ts": {
      "prompt": "\nEach user should have username (string), password (string), optional email (string), optional bio (string), and topBarColor (hex string with default `#ff6600`). Actions should be\n- create(username, password)\n- update(id, email, bio)\n- authenticate\n- changePassword\n- getById\n- getByIds, mapping from id to user\n- getByUsername\n- changeTopBar\n\n",
      "spec": "UserDoc = {\n  username: string;\n  password: string;\n  email?: string;\n  bio?: string;\n  topBarColor: string;\n}\n\nUserConcept = {\n  constructor: (collectionName: string) => UserConcept; // initializes UserConcept with the collection name and creates a unique index on username\n  async create: (username: string, password: string) => {msg: string, user: UserDoc}; // creates a new user; throws error if username is taken\n  async getById: (_id: ObjectId) => UserDoc; // retrieves a user by ID; throws error if not found. Does not return the password field\n  async getByIds: (ids: ObjectId[]) => Record<string, UserDoc>; // retrieves multiple users by IDs; returns a mapping of IDs to user objects. Does not return the password fields\n  async getByUsername: (username: string) => UserDoc; // retrieves a user by username; throws error if not found. Does not return the password field\n  async update: (_id: ObjectId, email?: string, bio?: string) => {msg: string}; // updates a user's email and bio\n  async authenticate: (username: string, password: string) => {msg: string, _id: ObjectId}; // authenticate a user with username and password; throws error if not found or password incorrect\n  async changePassword: (_id: ObjectId, oldPassword: string, newPassword: string) => {msg: string}; // changes a user's password; throws error if old password is incorrect or user not found\n  async changeTopBar: (_id: ObjectId, topBarColor: string) => {msg: string}; // changes a user's top bar color\n}"
    },
    "websession.ts": {
      "prompt": "This concept was implemented by a human.",
      "spec": "WebSessionDoc = {\n  user?: string;\n}\n\nWebSessionConcept = {\n  constructor: () => WebSessionConcept;\n  start: (session: WebSessionDoc, user: ObjectId) => void; // throws error if session already has a user\n  end: (session: WebSessionDoc) => void; // throws error if session doesn't have a user\n  getUser: (session: WebSessionDoc) => ObjectId | undefined; // returns the user in session or undefined\n  assertLoggedIn: (session: WebSessionDoc) => void; // throws error if session doesn't have a user\n  assertLoggedOut: (session: WebSessionDoc) => void; // throws error if session already has a user\n}"
    },
    "karma.ts": {
      "prompt": "\nEach karma should have user (generic) and points (number). Actions should be:\n- increase(user, x)\n- decrease(user, x)\n- get(user),\n- isAllowed(user, threshold), throws error if user doesn't have at least threshold\n\n",
      "spec": "KarmaDoc = {\n  user: ObjectId;\n  points: number;\n}\n\nKarmaConcept = {\n  constructor: (collectionName: string) => KarmaConcept; // instantiates a new KarmaConcept with the given collection name\n  async increase: (user: ObjectId, x: number) => void; // increases the karma points for a user; creates a new karma record if not exists\n  async decrease: (user: ObjectId, x: number) => void; // decreases the karma points for a user; throws NotAllowedError if resulting in negative karma\n  async get: (user: ObjectId) => number; // returns the karma points for a user; returns 0 if the user has no karma record\n  async isAllowed: (user: ObjectId, threshold: number) => void; // throws NotAllowedError if user's karma points do not meet the threshold\n}"
    },
    "mark.ts": {
      "prompt": "\nEach mark should have user (generic) and item (generic). Actions should be:\n- mark\n- unmark\n- getByUser\n- getByItem\n- isMarked, returns if item is marked by user",
      "spec": "MarkDoc = {\n  user: ObjectId;\n  item: ObjectId;\n}\n\nMarkConcept = {\n  constructor: (collectionName: string) => MarkConcept; // instantiates a new MarkConcept with the given collection name\n  async mark: (user: ObjectId, item: ObjectId) => {msg: string}; // marks an item for a user, returns message indicating success or if the item is already marked\n  async unmark: (user: ObjectId, item: ObjectId) => {msg: string}; // unmarks an item for a user, throws error if mark doesn't exist\n  async getByUser: (user: ObjectId) => MarkDoc[]; // retrieves all marks made by a user\n  async getByItem: (item: ObjectId) => MarkDoc[]; // retrieves all users who marked a specific item\n  async getByItems: (items: ObjectId[]) => MarkDoc[]; // retrieves all marks for a list of items\n  async isMarked: (user: ObjectId, item: ObjectId) => boolean; // checks if a specific item is marked by a user\n}"
    },
    "comment.ts": {
      "prompt": "\nEach comment should have author (generic), parent (generic), root (generic), and content (string), depth (number). root refers to the root of the comment chain and usually is another generic type. Actions should be\n- create(author, content, parent) where parent could be a comment or another generic (in which case it's also the root).\n- update\n- delete, only works if given comment has no comments under it\n- getById\n- getByAuthor\n- getById\n- getByIds, mapping from id to comment\n- getByParent(id), which should return comments in the subtree of id (could be comment or other generic) as flattened list\n- countByRoots(roots), mapping from each root to their comment count\n- isUserAuthor\n\n",
      "spec": "CommentDoc = {\n  author: ObjectId;\n  content: string;\n  parent: ObjectId;\n  root: ObjectId;\n  depth: number;\n}\n\nCommentConcept = {\n  constructor: (collectionName: string) => CommentConcept; // instantiates a new CommentConcept with the given collection name\n  async create: (author: ObjectId, content: string, parent: ObjectId) => CommentDoc; // creates a new comment and returns the created comment document\n  async update: (_id: ObjectId, content: string) => UpdateResult; // updates comment content by id, throws NotFoundError if comment doesn't exist\n  async delete: (_id: ObjectId) => {msg: string}; // deletes a comment by id, throws NotAllowedError if there are child comments\n  async getById: (_id: ObjectId) => CommentDoc; // gets a comment by id, throws NotFoundError if comment doesn't exist\n  async getByAuthor: (author: ObjectId) => CommentDoc[]; // gets comments by author\n  async getByIds: (ids: ObjectId[]) => Record<string, CommentDoc>; // gets comments by an array of ids and returns a map of id to comment\n  async getByParent: (parent: ObjectId) => CommentDoc[]; // gets comments that are in the subtree of the specified parent\n  async countByRoots: (roots: ObjectId[]) => Record<string, number>; // counts comments by each root in the provided array and returns a map of root id to count\n  async isUserAuthor: (_id: ObjectId, user: ObjectId) => boolean; // checks if the specified user is the author of the specified comment\n}\n"
    },
    "vote.ts": {
      "prompt": "\nEach vote should have author (generic), item (generic) and vote type (up or down). Actions should be\n- upvote\n- downvote\n- unvote\n- getUpvoted(author)\n- getVote(author, item)\n- getVotes(author, items?), mapping from item to vote\n- getItemPts, should return difference between upvotes and downvotes\n- getItemsPts(ids), should return mapping from each id to its point\n\nIf user has voted for an item, they must unvote first to vote again.\n\n",
      "spec": "VoteDoc = {\n  author: ObjectId;\n  item: ObjectId;\n  type: 'up' | 'down';\n}\n\nVoteConcept = {\n  constructor: (collectionName: string) => VoteConcept; // instantiates a new VoteConcept with the given collection name\n  async upvote: (author: ObjectId, item: ObjectId) => void; // throws error if user already voted\n  async downvote: (author: ObjectId, item: ObjectId) => void; // throws error if user already voted\n  async unvote: (author: ObjectId, item: ObjectId) => void; // removes vote for given author and item\n  async getUpvoted: (author: ObjectId) => VoteDoc[]; // returns all upvotes by an author\n  async getVote: (author: ObjectId, item: ObjectId) => VoteDoc | null; // returns specific vote by an author on an item\n  async getVotes: (author: ObjectId, items?: ObjectId[]) => Record<string, VoteDoc>; // returns votes by an author on specified items, if any\n  async getItemPts: (item: ObjectId) => number; // calculates net points for an item based on upvotes and downvotes\n  async getItemsPts: (ids: ObjectId[]) => Record<string, number>; // calculates net points for multiple items\n}"
    },
    "post.ts": {
      "prompt": "\nEach post should have author (generic), title (string), optional url (string), optional text (string). Actions should be\n- create\n- update\n- delete\n- getByAuthor\n- get(options?: {dateStart?, dateEnd?, page?, count?, titlePrefix?}) where default page=1, count=30\n- getById\n- getByIds, mapping from id to post\n- isUserAuthor\n\nUpdate and delete can only happen within 2 hours of creation. All get actions should return sorted results based on creation date.\n\n",
      "spec": "PostDoc = {\n  author: ObjectId;\n  title: string;\n  url?: string;\n  text?: string;\n}\n\nGetPostsOptions = {\n  dateStart?: Date;\n  dateEnd?: Date;\n  page?: number;\n  count?: number;\n  titlePrefix?: string;\n}\n\nPostConcept = {\n  constructor: (collectionName: string) => PostConcept; // instantiates a new PostConcept with the given collection name\n  async create: (author: ObjectId, title: string, url?: string, text?: string) => PostDoc; // creates a new post and returns it\n  async update: (_id: ObjectId, author: ObjectId, title: string, url?: string, text?: string) => void; // updates an existing post, throws error if not found, not author, or beyond editable time\n  async delete: (_id: ObjectId, author: ObjectId) => void; // deletes an existing post, throws error if not found, not author, or beyond deletable time\n  async getByAuthor: (author: ObjectId) => PostDoc[]; // gets posts by author, sorted by creation date descending\n  async get: (options?: GetPostsOptions) => PostDoc[]; // gets posts based on options, sorted by creation date descending\n  async getById: (_id: ObjectId) => PostDoc; // gets a single post by id, throws error if not found\n  async getByIds: (ids: ObjectId[]) => Record<string, PostDoc>; // gets posts by an array of ids, returns a map of id to PostDoc\n  async isUserAuthor: (_id: ObjectId, author: ObjectId) => boolean; // checks if a given user is the author of the post\n}"
    }
  }
}